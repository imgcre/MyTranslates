# 简介
翻译自[简介](https://www.boost.org/doc/libs/1_68_0/libs/spirit/doc/html/spirit/introduction.html)
Boost Spirit是一个面向对象、递归下降的语法分析器，并且能为c++输出生成库。它允许你在c++中直接使用类似EBNF的语法来书写文法和格式描述。这些内联的文法说明能够自由地和其他c++代码混合，并且感谢c++模板的可生成能力，这些都是立即可执行的。作为回顾，传统的编译器-编译器或者语法分析器生成器需要执行一个额外的翻译步骤来将EBNF代码转换为C或者C++代码。
此库API的语法和语义直接来自DSEL（特定领域的嵌入式语言）。实际上Spirit为用户提供了3个不同的DSEL：
- 一个用来创建语法分析器文法
- 一个用来指定语法分析所需要的单词
- 一个用来描述所需的输出格式

自目标输出文法和输出格式完全在c++中书写开始我们不再需要分离编译、预处理或集成这工具到构造过程的工具。Spirit允许无缝地通过其他C++代码整合语法解析和输出生成过程。这将使代码变成更加简单和高效。
创建语法分析器和生成器的功能都被完整提供了，这允许你更简单的处理内存中的分层数据结构。这些数据结构和输入的数据的结构类似并且能直接用来生成任意格式的输出。
![Boost Spirit库的整体结构](https://www.boost.org/doc/libs/1_68_0/libs/spirit/doc/html/images/spiritstructure.png)
上图展示了Boost Spirit库的整体结构。此库包括4个主要部分：
- `Spirit.Classic`: 这是从Boost Spirit的1.8版本带来的基本没有改变的代码。1.8版本的Boost Spirit被移动到了命名空间`boost::spirit::classic`下。通过加入这个特殊的兼容层来完成现存使用Spirit 1.8的代码的兼容工作。
- `Spirit.Qi`: 这是个语法分析器库，允许你创建递归下降的语法分析器。EDSL能将文法描述为实现，以及存储语法分析器信息的规则
- `Spirit.Lex`: 这是个易用的用来创建单词化器的库，由Spirit.Lex提供的DSEL允许你定义正则表达式来匹配单词（创建单词定义），将这些正则表达式和将被在匹配时执行的代码联系起来，并且将这些单词定义添加进词法分析器中。
- `Spirit.Karma`: 这个是生成器库，允许你为递归下降、数据类型驱动输出格式创建代码。所提供的DSEL基本和`Spirit.Qi`中使用的语法分析器描述语言基本相等。除了他是用来描述从给定的数据结构所需输出的格式的生成方法。


`Spirit.Qi`、`Spirit.Karma`、`Spirit.Lex`这三个组件被设计为能够被单独使用，或者一起使用。通常的方法论是使用Spirit.Lex生成的单词序列作为由`Spirit.Qi`生成的语法分析器的输入。在方程式的另一边，通过`Spirit.Qi`生成的分层的数据结构被通过`Spirit.Karma`生成的输出生成器使用。但是，只使用其中其一的库也是可以的。
下图展示了典型的某些输入被转换为内部表达的数据流。在经过一些（可选的）变换之后这些数据能被转换为一些不同的、扩展的表达。下图高亮了Spirit在数据转换流中的位置。
![Spirit.Qi和Spirit.Karma在典型的数据转换流中的位置](https://www.boost.org/doc/libs/1_68_0/libs/spirit/doc/html/images/spiritkarmaflow.png)
## 通过`Spirit.Qi`进行语法分析
`Spirit.Qi`是用来处理基于一个给定的目标文法(基本上是一个对将要读取的数据的格式的描述)生成语法分析器的子库。
一个简单的EBNF文法片段
``` EBNF
group       ::= '(' expression ')'
factor      ::= integer | group
term        ::= factor (( '*' factor) | ('/' factor))*
expression  ::= term (('+' term) | ('-' term))*
```
可以使用`Spirit.Qi`子库中的工具书写近似的语法，像如下代码片段一样
``` c++
group       = '(' >> expression >> ')';
factor      = integer | group;
term        = factor >> *(('*' >> factor) | ('/' >> factor));
expression  = term >> *(('+' >> term) | ('-' >> term));
```
通过表达式模板的魔法，这是完全有效的并且是可执行的c++代码。产生式`expression`实际上是一个包含成员函数`parse`(*????*)的对象。这是一个计算器，我们现在可以通过跳过类型声明和由`actor`调用的`integer`式来简化具体代码。现在在文法中的指定的产生式`expression`，通常情况下称为`start`符号，能够识别像下面的这些输入
``` python
12345
-12345
+12345
1 + 2
1 * 2
1/2 + 3/4
1 + 2 + 3 + 4
(1 + 2) * (3 + 4)
1 + ((6 * 200) - 20) / 6
(1 + (2 + (3 + (4 + 5))))
```
当然我们修改了原来的EBNF语法，使他符合C++的语法规则。尤其是我们看到了大量的位移`>>`操作符。，因为在C++中没有'空白'操作符，所以没有可能写出像`a b`这样的代码。像在数学语法中，比如为了表示乘法，或者，在我们这种情况，在EBNF语法中表示序列的操作（`b`需要跟在`a`之后），`Spirit.Qi`使用位移`>>`操作符以这种意图来代替它。我们使用使用`>>`操作符，以一个指向右边的箭头，来表示"被跟随"，所以我们可以这么写
``` c
a >> b
```
选择操作符`|`和圆括号`()`保持不变，赋值操作符`=`用来替代EBNF的`::=`。最后，星号`*`，在EBNF中为后缀操作符，在此成为了前缀，为了代替`a* //EBNF语法`，我们可书写：
``` c
*a //spirit语法
```
这是由于在C/C++中没有后缀的`*`。最后，我们可以用`,`或者`;`来结束一个规则。
## 通过`Spirit.Karma`生成输出
Spirit不仅允许你描述输入的结构，它同样允许你以相似的方式指定输出的格式，并且基于一个单一的语法和兼容的语义。
让我们假设我们需要从一个简单的数据结构比如`std::vector<int>`中生成一个文本的表达。转换的代码可能像下面这样：
``` c++
std::vector<int> v (initialize_and_fill());
std::vector<int>::iterator end = v.end();
for (std::vector<int>::iterator it = v.begin(); it != end; ++it)
    std::cout << *it << std::endl;
```
这不灵活并且当需要改变输出的格式时难以维护。Spirit的子库`Karma`允许你以一种灵活的方式从任意的数据结构指定输出的格式。下面是用来和创建上面传统代码相同输出的`Karma`格式描述的片段。
``` c++
*(int << eol)
```
下面是更多的`std::vector<int>`不同输出格式的例子：
| 格式 |
| --- |
| `'[' << *(int_ << ',') << ']'` |
| `*('(' << int_ << ')' << ',')` |
| `*hex` |
| `*(double_ << ',')` |
我们会在此文档后看到如何避免输出末尾的','
大体上，这语法和`Spirit.Qi`类似，我们用`<<`操作符来进行输出合并。由于它沿袭了在标准I/O流中的习俗，这应该很容易理解。
另一个在`Spirit.Karma`中的重要特性允许你完全将来自输出格式的数据类型解耦。你能在不同的数据类型上使用相同的输出格式，因为他们在概念上一致。下面的表格给出了一些相关的例子：
| 数据类型 | 描述 |
| --- | --- |
| `int i[4]` | c风格的数组 |
| `std::vector<int>` | 标准向量 |
| `std::list<int>` | 标准列表 |
| `boost::array<long, 20>` | boost数组 |
