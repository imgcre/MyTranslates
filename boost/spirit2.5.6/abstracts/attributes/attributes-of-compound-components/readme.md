## 复合组件属性
`Spirit.Qi`和`Spirit.Karma`为所有组合解析器和生成器实现了良定义的属性值传播规则，比如序列，选择，星号等等。序列主要的属性传播规则，比如：  

| 库 | 序列属性传播规则 |
| --- | --- |
| Qi | a: A, b: B --> (a >> b): tuple<A, B> |
| Karma | a: A, b: B --> (a << b): tuple<A, B> |

读作：给定解析器（或生成器）`a`和`b`，`A`是`a`的属性类型，`B`是`b`的属性类型，那么`a >> b`（`a << b`）的属性类型为`tuple<A, B>`。  
> **注意：**记号`tuple<A, B>`是任何能够容纳类型A和B的融合序列的占位符表达式，比如`boost::fusion::tuple<A, B>`或者`std::pair<A, B>`（详见[Boost.Fusion](https://www.boost.org/doc/libs/1_68_0/libs/fusion/doc/html/index.html)）  

如你所见，为了得到兼容于组合表达式属性类型的类型，必须要：  
- 每个都可转型为属性类型
- 或者它需要暴露特定的功能，比如，它需要符合与组件相兼容的概念

每个复合组件实现了它本身的一系列属性传播规则。为了得到复合生成器消费属性的不同之处的完整列表，请看章节`解析器复合属性规则`和`生成器复合属性规则`。(*TODO*)  
### 序列解析器和生成器的属性
序列需要一个属性类型来暴露融合序列的概念，所有在融合序列中的元数都要可转换为相应的组合序列中的元素，比如，表达式：

| 库 | 序列表达式 |
| --- | --- |
| Qi | `double_ >> double_` |
| Karma | `double_ << double_` |

和任何包含两个都和double相兼容的类型的融合序列相兼容。融合序列的第一个元素必须和第一个`double_`的属性相兼容，第二个融合序列中的元素必须和第二个`double_`的属性相兼容。如果我们假设有一个`std::pair<double, double>`的实例，我们能够直接使用上述两个表达式，解析输入来填充属性：
``` c++

```