## 规则和文法的属性
非终结符在解析器中很常见，他们被用作从简单解析器中构造更复杂的解析器的主要方式。在解析器世界中的非终结符和命令式编程语言中的函数非常相似。他们被用来封装处理特定输入序列的解析器表达式。在被定义后，只要被封装的输入需要被识别，非终结符就能在更复杂的表达式中用作普通的解析器。在`Spirit.Qi`中的解析器非终结符可以接受参数（继承属性），并且通常返回一个值（合成属性）。  
同样，继承属性和合成属性的类型必须在定义特定*文法*或*规则*时被明确指定。下面的代码声明了一个公开了`int`作为它的合成属性的`Spirit.Qi`规则，它期望`double`作为它的继承属性（看`Spirit.Qi`规则章节获得更多信息）：  
``` c++
qi::rule<Iterator, int(double)> r;
```
在生成器的世界中，非终结符和解析器世界中的一样实用。生成器非终结符封装了一个特定数据类型的格式化描述，并且单我们需要为这个数据类型产生输出的时候，相应的非终结符会按和`Spirit.Karma`中预定义的原生生成器相似的方式被调用。`Spirit.Karma`的非终结符和`Spirit.Qi`的非终结符非常相似。生成器非终结符也可以接受参数，并且也被称作继承属性。主要的不同是他们不公开合成属性（但解析器公开了），当他们需要一个特定的*消费属性*。通常生成器从消费属性创建它输出的值。即使消费属性不从生成器返回，我们也使用和`Spirit.Qi`相同的函数风格声明语法。下面的例子声明了一个消费`double`并且不需要任何额外的继承属性的`Spirit.Karma`规则：  
``` c++
karma::rule<OutputIterator, double()> r;
```
非终结解析器和非终结生成器的继承属性通常在它被调用时传递给组件，这是解析器或生成器可能接受的*参数*，他们能用来参数化依赖他们被调用处上下文的组件。  