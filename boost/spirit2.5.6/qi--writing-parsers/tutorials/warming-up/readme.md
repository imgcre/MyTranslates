# 预热
我们将首先展示解析器表达式的示例，让您了解如何从最简单的解析器构建解析器，并随心所欲地构建。当将`EBNF`与`Spirit`相比较时，这些表达式一开始可能显得很奇怪。`Spirit`大量使用运算符重载来实现它的魔力。  
## 例子 #1 解析一个数值
创建一个解析浮点数的解析器  
``` c++
double_
```
（你必须承认，这是很简单的。）上面的代码实际上生成了一个`Spirit`浮点解析器（一个内置解析器）。`Spirit`有许多预定义的解析器，一致的命名规范使你不再为此抓狂。  

## 例子 #2 解析两个数值
创建一个解析器，它接受由两个浮点数组成的输入。  
```
double_ >> double_
```
在这里你将看到熟悉的浮点数解析器`double_`被用了两次（为每个数值都使用了一次）。那么`>>`操作符在这里扮演什么角色呢？其实`double_`等解析器需要被某种东西分隔开，然后`>>`是用来充当"被跟随"序列操作符的。上面的程序从两个更简单的解析器中创建了一个更复杂的解析器，并将这两个操作符通过序列操作符连接连接在了一起。其结果是：一个解析器是更小的解析器的一种组合。数值之间的空格可以被隐式地被解析器消耗，取决于解析器是如何被调用的（见下文）。
> 注意：但我们结合解析器是，我们最终会得到一个更大的解析器，但是这个更大的解析器仍然是个解析器。解析器能变得越来越大，嵌套得越来越深，但当你将两个解析器连接在一起时，你得到一个更大的解析器。这是一个重要的概念。  

## 例子 #3 解析零个或者多个数值
创建接受零个或多个浮点数值的解析器：
``` c++
*double_
```
这和正则表达式中的`*`很像。但是他看起来比较奇怪，因为多数C++程序员不曾看到`*`操作符被这样重载。实际上，如果你了解过正则表达式，他看起来也会很奇怪，因为`*`写在所作用的表达式之前。这就是生活，你应该怪现在用的是C++的语法规则。  
任何是解析式的表达式，都可以使用`*`。注意在C++的操作符优先级规则中，你需要将所要操作的表达式放在括号中。  

## 例子 #4 解析由逗号分割的数值序列
创建接受逗号分割的数值序列的解析器
``` c++
double_ >> *(char_(',') >> double_)
```
注意`char_(',')`是个字面量字符解析器，他能识别逗号`,`。在本例中，`*`作用于了一个更复杂的，由表达式生成的解析器。  
``` c++
(char_(',') >> double_)
```
注意这种情况下括号是必须的，`*`作用于上面整个表达式。  

## 开始解析
我们已经完成了对解析器的定义，下个步骤是通过调用使解析器工作。调用解析器的方式多种多样，下面先使用`phrase_parse`函数调用解析器。`phrase_parse`函数的其中一个重载接受四个参数：  
- 指向输入开头的迭代器
- 指向输入结尾的迭代器
- 解析器对象
- skip解析器

skip解析器负责跳过解析器元素间的字符（比如`double_`和`char_`之间的）。在Spirit预定义解析器中，名为`space`的解析器能识别空格和tab。在下面的例子中，我们将使用`space`作为skip解析器，从而跳过空格和tab。  
所以现在，开始解析吧：  
``` c++
template <typename Iterator>
bool parse_numbers(Iterator first, Iterator last)
{
    using qi::double_;
    using qi::phrase_parse;
    using ascii::space;

    bool r = phrase_parse(
        first,                          //起始迭代器
        last,                           //终止迭代器
        double_ >> *(',' >> double_),   //解析器
        space                           //skip解析器
    );
    if (first != last) //如果我们没有完整匹配，那么就是匹配失败
        return false;
    return r;
}
```
`parse`函数根据解析的结果返回`true`或`false`。调用`parse`函数时，起始迭代器参数是传引用的。如果解析成功，有`first == last`，此时起始迭代器移动到了`parse`函数所使用的最右边的位置，输入被完整匹配；如果`first != last`，也即解析器只能解析一部分输入时，输入被部分匹配。  
注意我们在调用`parse`函数时直接内联了解析器。在调用`parse`函数之前，解析器表达式`double_ >> *(',' >> double_)`计算出了一个临时的，未命名的解析器，他被传递给了`parse`函数，并在使用完之后被销毁。  
在本例中，我们使用模板泛化解析器，通过迭代器类型实现模板参数化。这么做的好处是：只要Iterator是前向迭代器，`parse_number`就能处理其中的数据。  
[点击这里查看完整的cpp文件](examples/num_list1.cpp)  

> 注意-关于`char`和`wchar_t`操作数：  
细心的读者可能已经发现，上面例子中的解析器表达式用`','`代替了`char_(',')`。这是合乎C++的转型语法规则的。解析器存在接受参数类型为`char`或者`wchar_t`的`<<`的操作符重载（此类操作数可以出现在`<<`的左边或者右边，但不能同时出现在两边）。在至少有一个操作数为用户定义类型时，操作数可以被重载。在上例中，`double_`是操作符`>>`的第二个操作数，所以可以使用相应的`>>`重载，将`','`转换为字符字面量解析器。  
转换`char_`的问题是显而易见的：`'a' >> 'b'`不是一个spirit解析器，而是一个数值表达式，语义是右移`'a'`的ASCII（或其他编码）值`'b'`次。但是，`char_('a') >> 'b'`和`'a' >> char_('b')`都是spirit序列表达式，语义是`'a'`字符跟随在`'b'`字符之后。不久你就会习惯的。

